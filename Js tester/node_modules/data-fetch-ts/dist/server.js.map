{"version":3,"sources":["../src/server.ts"],"sourcesContent":["\"use server\";\r\n\r\ntype Methods = 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';\r\ntype cache = 'default' | `force-cache` | `no-cache` | `no-store ` | `only-if-cached` | `reload`\r\n\r\ntype RequestBody = {\r\n    [key: string]: any;\r\n};\r\n\r\n// Conditional type for FetchOptions to enforce body requirement\r\ntype FetchOptions<M extends Methods> = M extends 'POST' | 'PUT' | 'PATCH'\r\n    ? {\r\n        endpoint: string;\r\n        method: M;\r\n        token?: string;\r\n        body: RequestBody;\r\n        cash?: cache\r\n        // Body is required for POST, PUT, PATCH\r\n    }\r\n    : {\r\n        endpoint: string;\r\n        method?: M;  // Optional method defaults to GET\r\n        token?: string;\r\n        cash?: cache\r\n        body?: RequestBody;  // Body is optional for other methods\r\n    };\r\n\r\nconst fetchData = async <M extends Methods>({ endpoint, method = 'GET', token, body }: FetchOptions<M>): Promise<any> => {\r\n    const headers: HeadersInit = {\r\n        'Content-Type': 'application/json',\r\n    };\r\n\r\n    if (token) {\r\n        headers['Authorization'] = `Bearer ${token}`;\r\n    }\r\n\r\n    const fetchOptions: RequestInit = {\r\n        method,\r\n        headers,\r\n    };\r\n\r\n    if (body) {\r\n        fetchOptions.body = JSON.stringify(body);\r\n    }\r\n\r\n    const response = await fetch(endpoint, fetchOptions);\r\n\r\n    return response.json();\r\n};\r\n\r\nexport default fetchData"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AA2BA,IAAM,YAAY,CAA0B,OAA6E,iBAA7E,KAA6E,WAA7E,EAAE,UAAU,SAAS,OAAO,OAAO,KAAK,GAAqC;AACrH,QAAM,UAAuB;AAAA,IACzB,gBAAgB;AAAA,EACpB;AAEA,MAAI,OAAO;AACP,YAAQ,eAAe,IAAI,UAAU,KAAK;AAAA,EAC9C;AAEA,QAAM,eAA4B;AAAA,IAC9B;AAAA,IACA;AAAA,EACJ;AAEA,MAAI,MAAM;AACN,iBAAa,OAAO,KAAK,UAAU,IAAI;AAAA,EAC3C;AAEA,QAAM,WAAW,MAAM,MAAM,UAAU,YAAY;AAEnD,SAAO,SAAS,KAAK;AACzB;AAEA,IAAO,iBAAQ;","names":[]}